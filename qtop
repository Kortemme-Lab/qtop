#!/usr/bin/env python2
# -*- mode:python;show-trailing-whitespace:t; -*-

"""
Show which jobs are running on the cluster.

Usage:
    qtop [options]

Options:
    -u --user=NAME
        The name(s) of the user(s) to display information for.  By default, the
        user calling the program will be used.  Specify '*' to see all users.

    -p --project=NAME
        The name(s) of the project(s) to display information for.  By default,
        the projects that user calling the program belongs to will be used.
        Specify '*' to see all projects.

    -i --interval=INTERVAL
        Run the program in interactive mode, refreshing qstat data every
        interval seconds [default: 0]

    --test
        Instead of running qstat, parse from output files in the testing_output
        directory

"""

import subprocess, getpass, collections, itertools
import os
import time
import random
from Queue import Queue
from threading import Thread
from blessings import Terminal
term = Terminal()

def sh(cmd):
    """
    Run the given command in a shell.

    The command should be a single string containing a shell command.  If the
    command contains the names of any local variables enclosed in braces, the
    actual values of the named variables will be filled in.  (Note that this
    works on variables defined in the calling scope, which is a little bit
    magical.)  Regular braces must be escaped as you would with str.format().
    Also be aware that this approach is vulnerable to shell injection attacks.
    """

    # Figure out what local variables are defined in the calling scope.

    import inspect
    frame = inspect.currentframe()
    try: locals = frame.f_back.f_locals
    finally: del frame

    # Run the given command in a shell.  Return everything written to stdout if
    # the command returns an error code of 0, otherwise raise an exception.

    from subprocess import Popen, PIPE, CalledProcessError
    process = Popen(cmd.format(**locals), shell=True, stdout=PIPE)
    stdout, unused_stderr = process.communicate()
    retcode = process.poll()
    if retcode:
        error = subprocess.CalledProcessError(retcode, cmd)
        error.output = stdout
        raise error
    return stdout.strip()


def choose_user(user=None):
    if user is not None:
        return user
    else:
        import getpass
        return getpass.getuser()

def choose_project(project=None, user=None):
    if project is not None:
        return project
    else:
        user = choose_user(user)
        return sh('''\
                qconf -suser {user} |
                grep default_project |
                awk '{{print $2}}' ''')


class Job (object):
    def __init__(self, qstat_line):
        fields = qstat_line.split()
        try:
            self.update_from_fields(fields)
        except:
            print 'Error parsing qstat line:'
            print '  ', qstat_line
            raise

        # This is everything but "name" so far
        self.basic_attrs_to_update = [
            'id', 'prior', 'ntckts', 'user', 'project',
            'department', 'state', 'cpu', 'mem', 'io',
            'tckts', 'ovrts', 'otckt', 'ftckt', 'stckt',
            'share', 'queue', 'slots', 'ja_task_id',
        ]

    def update_from_fields(self, fields):
        self.id = long(fields[0])
        self.prior = fields[1]
        self.ntckts = fields[2]
        self.name = fields[3]
        self.short_name = self.name
        self.user = fields[4]
        self.project = fields[5]
        self.department = fields[6]
        self.state = fields[7]

        if 'r' in self.state:
            self.cpu = fields[8]
            self.mem = fields[9]
            self.io = fields[10]
            self.tckts = fields[11]
            self.ovrts = fields[12]
            self.otckt = fields[13]
            self.ftckt = fields[14]
            self.stckt = fields[15]
            self.share = fields[16]
            self.queue = fields[17]
            self.slots = fields[18]
            try: self.ja_task_id = fields[16]
            except IndexError: self.ja_task_id = ''

        else:
            self.cpu = None
            self.mem = None
            self.io = None
            self.tckts = fields[8]
            self.ovrts = fields[9]
            self.otckt = fields[10]
            self.ftckt = fields[11]
            self.stckt = fields[12]
            self.share = fields[13]
            self.queue = None
            self.slots = fields[14]
            try: self.ja_task_id = fields[15]
            except IndexError: self.ja_task_id = ''

    def update(self, other):
        for attr in self.basic_attrs_to_update:
            setattr(self, attr, getattr(other, attr))

    def set_qstat_data(self, qstat_data):
        self.qstat_data = qstat_data

        if 'job_name' in qstat_data:
            self.full_name = qstat_data['job_name']
            self.name = self.full_name

def update_job_data(job_id_queue, results_queue, testing_mode):
    while True:
        if not job_id_queue.empty():
            job_id = job_id_queue.get()

            if testing_mode:
                qstat_file = 'testing_output/job_specific_output/%d' % job_id
                if os.path.isfile(qstat_file):
                    with open(qstat_file, 'r') as f:
                        qstat_output = f.readlines()
                else:
                    qstat_output = None
            else:
                try:
                    qstat_output = sh('qstat -j %d' % job_id).split('\n')
                except:
                    qstat_output = None

            if qstat_output:
                qstat_data = {}
                for line in qstat_output[1:]:
                    fields = line.split(':')
                    if len(fields) == 2:
                        qstat_data[fields[0].strip()] = fields[1].strip()
                if len(qstat_data) > 0:
                    results_queue.put(qstat_data)
                    time.sleep(2.0) # Only run qstat -j every n seconds
        else:
            time.sleep(0.1) # Check queue more often

class Jobs (object):
    def __init__(self, testing_mode, project):
        self.jobs = {}
        self.project = project
        self.test_iteration = 0
        self.testing_mode = testing_mode

        self.jobs_to_update = Queue()
        self.updated_jobs_results = Queue()
        self.job_data_updater = Thread(
            target=update_job_data,
            args = (
                self.jobs_to_update,
                self.updated_jobs_results,
                self.testing_mode)
        )
        self.job_data_updater.daemon = True
        self.job_data_updater.start()

    def update(self):
        self.jobs = {}
        if self.testing_mode:
            input_data = read_from_test_output(self.test_iteration)
            self.test_iteration += 1
        else:
            input_data = sh('qstat -ext -u \\*').split('\n')

        parsed_job_ids = set()
        new_job_ids = set()
        old_job_ids = set(self.jobs.keys())
        for line in input_data[2:]:
            print line
            job = Job(line)
            parsed_job_ids.add(job.id)
            if job.id in self.jobs:
                print job.id
                self.jobs[job.id] = self.jobs[job.id].update(job)
            else:
                self.jobs[job.id] = job
                new_job_ids.add(job.id)

        missing_job_ids = old_job_ids.difference(parsed_job_ids)
        for job_id in missing_job_ids:
            term_print( 'Deleting %d' % job_id ) # TODO: remove this testing line if you see this note
            del self.jobs[job_id]

        new_job_ids_list = list(new_job_ids)
        random.shuffle(new_job_ids_list)
        for job_id in new_job_ids_list:
            job = self.jobs[job_id]
            if job.project == self.project and len(job.name) >= 10:
                self.jobs_to_update.put(job_id)

        # Get new qstat_data results from queue
        while not self.updated_jobs_results.empty():
            qstat_data = self.updated_jobs_results.get()
            job_id = long( qstat_data['job_number'] )
            self.jobs[job_id].set_qstat_data( qstat_data )

    def __iter__(self):
        self.sorted_job_ids = [
            x for x,y in self.jobs.iteritems() if y.state != 'finished'
        ]
        self.sorted_job_ids.sort(reverse=True)
        return self

    # Python 3 compatibility
    def __next__(self):
        return self.next()

    def next(self):
        if len(self.sorted_job_ids) == 0:
            raise StopIteration
        return self.jobs[ self.sorted_job_ids.pop() ]

def read_from_test_output(test_iteration):
    testing_output_dir = 'testing_output'
    assert( os.path.isdir( testing_output_dir ) )
    test_files = [
        os.path.join(testing_output_dir, f)
        for f in sorted(os.listdir(testing_output_dir))
        if 'job_specific_output' not in f
    ]

    term_print( test_files[test_iteration % len(test_files)] )
    with open(test_files[test_iteration % len(test_files)], 'r') as f:
        return f.readlines()

def term_print(string):
    global term
    string = str(string)
    for split_string in string.split('\n'):
        print str(string) + term.clear_eol

def display_jobs(jobs, filter, display='{count:>7d} {job.user:12} {job.name}'):
    job_counts = {}

    for job in itertools.ifilter(filter, jobs):
        job_name = job.user, job.name
        job_counts.setdefault(job_name, {'job': job, 'count': 0})
        job_counts[job_name]['count'] += 1

    if not job_counts:
        term_print( '  none' )

    for user, name in sorted(job_counts):
        job, count = job_counts[user, name]
        term_print( display.format(**job_counts[user, name]) )

def display_running_jobs(jobs):
    if jobs.project is None:
        term_print( "Currently running jobs:" )
        display_jobs(jobs, lambda j: j.state == 'r')
    else:
        term_print( "Currently running jobs by {0} users:".format(jobs.project) )
        display_jobs(jobs, lambda j: j.state == 'r' and j.project == jobs.project)

    term_print('') # spacer line

def display_queued_jobs(jobs):
    filter = lambda j: j.state == 'qw'
    display = '{count:>7d} {job.user:12} {job.name} ({job.ja_task_id})'

    if jobs.project is None:
        term_print( "Currently queued jobs:" )
        display_jobs(jobs, filter, display)
    else:
        term_print( "Currently queued jobs by {0} users:".format(jobs.project) )
        display_jobs(jobs, lambda j: filter(j) and j.project == jobs.project, display)

    term_print('') # spacer line


def display_remaining_jobs(jobs):
    filter = lambda j: j.state not in ('r', 'qw')
    display = '{count:>7d} {job.user:12} {job.name} ({job.state})'

    if jobs.project is None:
        term_print( "Remaining jobs:" )
        display_jobs(jobs, filter, display)
    else:
        term_print( "Remaining jobs by {0} users:".format(jobs.project) )
        display_jobs(jobs, lambda j: filter(j) and j.project == jobs.project, display)

def run( project, testing_mode=False, interval=0 ):
    # Figure out what projects to display information for.  If the user
    # specifies one or more projects on the command line, use them.  Otherwise
    # use the projects the current user belongs to.

    jobs = Jobs(testing_mode, project)
    while True:
        print term.clear()
        jobs.update()

        term_print( time.strftime("%a, %d %b %Y %H:%M:%S ") )
        display_running_jobs(jobs)
        display_queued_jobs(jobs)
        display_remaining_jobs(jobs)

        if float(interval) == 0.0:
            return
        else:
            # Let's rest this thread
            time.sleep(float(interval))

if __name__ == '__main__':
    import docopt
    args = docopt.docopt(__doc__)

    testing_mode = args['--test']
    interval = float(args['--interval'])
    project = choose_project(args['--project'])

    run( project, testing_mode=testing_mode, interval=interval )
