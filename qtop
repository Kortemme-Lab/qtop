#!/usr/bin/env python2
# -*- mode:python;show-trailing-whitespace:t; -*-

"""
Show which jobs are running on the cluster.

Usage:
    qtop [options]

Options:
    -u --user=NAME
        The name(s) of the user(s) to display information for.  By default, the
        user calling the program will be used.  Specify '*' to see all users.

    -p --project=NAME
        The name(s) of the project(s) to display information for.  By default,
        the projects that user calling the program belongs to will be used.
        Specify '*' to see all projects.

    -i --interval=INTERVAL
        Run the program in interactive mode, refreshing qstat data every
        interval seconds [default: 0]

    --test
        Instead of running qstat, parse from output files in the testing_output
        directory

"""

import subprocess, getpass, collections, itertools
import os
import time
from blessings import Terminal
term = Terminal()

# Global variable (for testing behavior only)
test_iteration = 0

def sh(cmd):
    """
    Run the given command in a shell.

    The command should be a single string containing a shell command.  If the
    command contains the names of any local variables enclosed in braces, the
    actual values of the named variables will be filled in.  (Note that this
    works on variables defined in the calling scope, which is a little bit
    magical.)  Regular braces must be escaped as you would with str.format().
    Also be aware that this approach is vulnerable to shell injection attacks.
    """

    # Figure out what local variables are defined in the calling scope.

    import inspect
    frame = inspect.currentframe()
    try: locals = frame.f_back.f_locals
    finally: del frame

    # Run the given command in a shell.  Return everything written to stdout if
    # the command returns an error code of 0, otherwise raise an exception.

    from subprocess import Popen, PIPE, CalledProcessError
    process = Popen(cmd.format(**locals), shell=True, stdout=PIPE)
    stdout, unused_stderr = process.communicate()
    retcode = process.poll()
    if retcode:
        error = subprocess.CalledProcessError(retcode, cmd)
        error.output = stdout
        raise error
    return stdout.strip()


def choose_user(user=None):
    if user is not None:
        return user
    else:
        import getpass
        return getpass.getuser()

def choose_project(project=None, user=None):
    if project is not None:
        return project
    else:
        user = choose_user(user)
        return sh('''\
                qconf -suser {user} |
                grep default_project |
                awk '{{print $2}}' ''')


class Job (object):

    def __init__(self, qstat_line):
        try:
            fields = qstat_line.split()

            self.id = fields[0]
            self.prior = fields[1]
            self.ntckts = fields[2]
            self.name = fields[3]
            self.user = fields[4]
            self.project = fields[5]
            self.department = fields[6]
            self.state = fields[7]

            if 'r' in self.state:
                self.cpu = fields[8]
                self.mem = fields[9]
                self.io = fields[10]
                self.tckts = fields[11]
                self.ovrts = fields[12]
                self.otckt = fields[13]
                self.ftckt = fields[14]
                self.stckt = fields[15]
                self.share = fields[16]
                self.queue = fields[17]
                self.slots = fields[18]
                try: self.ja_task_id = fields[16]
                except IndexError: self.ja_task_id = ''

            else:
                self.tckts = fields[8]
                self.ovrts = fields[9]
                self.otckt = fields[10]
                self.ftckt = fields[11]
                self.stckt = fields[12]
                self.share = fields[13]
                self.slots = fields[14]
                try: self.ja_task_id = fields[15]
                except IndexError: self.ja_task_id = ''

        except:
            print 'Error parsing qstat line:'
            print '  ', qstat_line
            raise



def query_jobs(testing_mode=False):
    jobs = []

    if testing_mode:
        input_data = read_from_test_output()
    else:
        input_data = sh('qstat -ext -u \\*').split('\n')

    for line in input_data[2:]:
        job = Job(line)
        jobs.append(job)

    return jobs

def read_from_test_output():
    global test_iteration
    test_iteration += 1
    testing_output_dir = 'testing_output'
    assert( os.path.isdir( testing_output_dir ) )
    test_files = [
        os.path.join(testing_output_dir, f)
        for f in sorted(os.listdir(testing_output_dir))
    ]

    with open(test_files[(test_iteration-1) % len(test_files)], 'r') as f:
        return f.readlines()

def term_print(string):
    global term
    for split_string in string.split('\n'):
        print str(string) + term.clear_eol

def display_jobs(jobs, filter, display='{count:>7d} {job.user:12} {job.name}'):
    job_counts = {}

    for job in itertools.ifilter(filter, jobs):
        job_name = job.user, job.name
        job_counts.setdefault(job_name, {'job': job, 'count': 0})
        job_counts[job_name]['count'] += 1

    if not job_counts:
        term_print( '  none' )

    for user, name in sorted(job_counts):
        job, count = job_counts[user, name]
        term_print( display.format(**job_counts[user, name]) )

def display_running_jobs(jobs, project=None):
    if project is None:
        term_print( "Currently running jobs:" )
        display_jobs(jobs, lambda j: j.state == 'r')
    else:
        term_print( "Currently running jobs by {0} users:".format(project) )
        display_jobs(jobs, lambda j: j.state == 'r' and j.project == project)

    term_print('') # spacer line

def display_queued_jobs(jobs, project=None):
    filter = lambda j: j.state == 'qw'
    display = '{count:>7d} {job.user:12} {job.name} ({job.ja_task_id})'

    if project is None:
        term_print( "Currently queued jobs:" )
        display_jobs(jobs, filter, display)
    else:
        term_print( "Currently queued jobs by {0} users:".format(project) )
        display_jobs(jobs, lambda j: filter(j) and j.project == project, display)

    term_print('') # spacer line


def display_remaining_jobs(jobs, project=None):
    filter = lambda j: j.state not in ('r', 'qw')
    display = '{count:>7d} {job.user:12} {job.name} ({job.state})'

    if project is None:
        term_print( "Remaining jobs:" )
        display_jobs(jobs, filter, display)
    else:
        term_print( "Remaining jobs by {0} users:".format(project) )
        display_jobs(jobs, lambda j: filter(j) and j.project == project, display)

def run( project, testing_mode=False, interval=0 ):
    # Figure out what projects to display information for.  If the user
    # specifies one or more projects on the command line, use them.  Otherwise
    # use the projects the current user belongs to.

    while True:
        jobs = query_jobs( testing_mode=testing_mode )

        print term.clear
        term.move(0, 0)
        term_print( time.strftime("%a, %d %b %Y %H:%M:%S ") )
        display_running_jobs(jobs, project)
        display_queued_jobs(jobs, project)
        display_remaining_jobs(jobs, project)

        if float(interval) == 0.0:
            return
        else:
            time.sleep(float(interval))

if __name__ == '__main__':
    import docopt
    args = docopt.docopt(__doc__)

    testing_mode = args['--test']
    interval = args['--interval']
    project = choose_project(args['--project'])

    run( project, testing_mode=testing_mode, interval=interval )
